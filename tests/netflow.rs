#[cfg(test)]
mod tests {
    extern crate netflow_v9;

    use std::fs::File;
    use std::io::Read;
    
    use self::netflow_v9::Parser;
    
    #[test]
    fn test_parse() {
        let packet_1: [u8; 230]  =
            [0x00,0x09,0x00,0x04,0x63,0x76,0x26,0xee,0x5a,0x20,0x85,0x54,0x00,0x01,0xef,0xb7,
             0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x01,0x01,0x00,0x18,0x00,0x08,0x00,0x04,
             0x00,0x0c,0x00,0x04,0x00,0x0f,0x00,0x04,0x00,0x12,0x00,0x04,0x00,0x0a,0x00,0x02,
             0x00,0x0e,0x00,0x02,0x00,0x02,0x00,0x04,0x00,0x01,0x00,0x04,0x00,0x16,0x00,0x04,
             0x00,0x15,0x00,0x04,0x00,0x07,0x00,0x02,0x00,0x0b,0x00,0x02,0x00,0x59,0x00,0x01,
             0x00,0x06,0x00,0x01,0x00,0x04,0x00,0x01,0x00,0x05,0x00,0x01,0x00,0x3c,0x00,0x01,
             0x00,0x3d,0x00,0x01,0x00,0x20,0x00,0x02,0x00,0x10,0x00,0x04,0x00,0x11,0x00,0x04,
             0x00,0x09,0x00,0x01,0x00,0x0d,0x00,0x01,0x00,0x63,0x00,0x04,0x00,0x01,0x00,0x18,
             0x01,0x00,0x00,0x04,0x00,0x08,0x00,0x01,0x00,0x04,0x00,0x23,0x00,0x01,0x00,0x22,
             0x00,0x04,0x00,0x00,0x01,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x03,
             0xe8,0x00,0x00,0x00,0x01,0x01,0x00,0x42,0xb9,0xa7,0xc4,0x7f,0xb9,0xa7,0xc4,0x7e,
             0x00,0x00,0x00,0x00,0xb9,0xa7,0xc4,0x7e,0x00,0x00,0x01,0x14,0x00,0x00,0x00,0x01,
             0x00,0x00,0x00,0x34,0x63,0x75,0x04,0xee,0x63,0x75,0x04,0xee,0xc0,0x00,0x0e,0xc8,
             0x42,0x00,0x11,0xc0,0x04,0x01,0x00,0x00,0x00,0x03,0x28,0xc4,0x00,0x03,0x28,0xc4,
             0x20,0x1f,0x00,0x00,0x00,0x00];
        
        let packet_2: [u8; 310] =
            [0x00,0x09,0x00,0x04,0x63,0x7a,0x70,0x96,0x5a,0x20,0x86,0x6d,0x00,0x01,0xef,0xbb,
             0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x01,0x05,0x00,0x1c,0x00,0x1b,0x00,0x10,
             0x00,0x1c,0x00,0x10,0x00,0x3e,0x00,0x10,0x00,0x3f,0x00,0x10,0x00,0x0f,0x00,0x04,
             0x00,0x12,0x00,0x04,0x00,0x0a,0x00,0x02,0x00,0x0e,0x00,0x02,0x00,0x02,0x00,0x04,
             0x00,0x01,0x00,0x04,0x00,0x16,0x00,0x04,0x00,0x15,0x00,0x04,0x00,0x07,0x00,0x02,
             0x00,0x0b,0x00,0x02,0x00,0x59,0x00,0x01,0x00,0x06,0x00,0x01,0x00,0x04,0x00,0x01,
             0x00,0x40,0x00,0x04,0x00,0x1f,0x00,0x04,0x00,0x05,0x00,0x01,0x00,0x3c,0x00,0x01,
             0x00,0x3d,0x00,0x01,0x00,0x20,0x00,0x02,0x00,0x10,0x00,0x04,0x00,0x11,0x00,0x04,
             0x00,0x1d,0x00,0x01,0x00,0x1e,0x00,0x01,0x00,0x63,0x00,0x04,0x00,0x01,0x00,0x18,
             0x01,0x00,0x00,0x04,0x00,0x08,0x00,0x01,0x00,0x04,0x00,0x23,0x00,0x01,0x00,0x22,
             0x00,0x04,0x00,0x00,0x01,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x03,
             0xe8,0x00,0x00,0x00,0x01,0x05,0x00,0x82,0x2a,0x0b,0xae,0x00,0x01,0x21,0x00,0x00,
             0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x2a,0x0b,0xae,0x00,0x01,0x21,0x00,0x00,
             0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
             0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2a,0x0b,0xae,0x00,0x01,0x21,0x00,0x00,
             0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
             0x00,0x00,0x01,0x14,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x48,0x63,0x79,0x4d,0xec,
             0x63,0x79,0x4d,0xec,0xc0,0x00,0x0e,0xc8,0x42,0x00,0x11,0x00,0x00,0x00,0x00,0x00,
             0x00,0x00,0x00,0xc0,0x06,0x01,0x00,0x00,0x00,0x03,0x28,0xc4,0x00,0x03,0x28,0xc4,
             0x80,0x7f,0x00,0x00,0x00,0x00];

        let mut parser = Parser::new();

        if let Ok(sets) = parser.parse_netflow_packet(&packet_1) {
            for set in sets {
                let s = set.to_json();
                println!("{}",s);
                assert!(s.contains("\"BGP IPv4 Next Hop\": \"185.167.196.126\""));
                assert!(s.contains("\"IPv4 Src Addr\": \"185.167.196.127\""));
                assert!(s.contains("\"ICMP type\": \"0\""));
                assert!(s.contains("\"Protocol\": \"17\""));
                assert!(s.contains("\"IPv4 Dest Addr\": \"185.167.196.126\""));
                assert!(s.contains("\"L4 Src port\": \"49152\""));
                assert!(s.contains("\"First switched\": \"1668613358\""));
                assert!(s.contains("\"BGP IPv4 Next Hop\": \"185.167.196.126\""));
                assert!(s.contains("\"Dest Mask\": \"31\""));
                assert!(s.contains("\"Input SNMP\": \"0\""));
                assert!(s.contains("\"Direction\": \"1\""));
                assert!(s.contains("\"Last Switched\": \"1668613358\""));
                assert!(s.contains("\"L4 Dst port\": \"3784\""));
                assert!(s.contains("\"Multicast replication factor\": \"0\""));
                assert!(s.contains("\"Forwarding Status\": \"66\""));
                assert!(s.contains("\"Src Mask\": \"32\""));
                assert!(s.contains("\"Dest Mask\": \"31\""));
                assert!(s.contains("\"Dst AS\": \"207044\""));
                assert!(s.contains("\"InPackets\": \"1\""));
                assert!(s.contains("\"IPv4 Next Hop\": \"0.0.0.0\""));
                assert!(s.contains("\"Src AS\": \"207044\""));
                assert!(s.contains("\"IP Proto version\": \"4\""));
                assert!(s.contains("\"TCP Flags\": \"0\""));
                assert!(s.contains("\"ICMP type\": \"0\""));
                assert!(s.contains("\"InBytes\": \"52\""));
                assert!(s.contains("\"Output SNMP\": \"276\""));
                assert!(s.contains("\"Src Tos\": \"192\""));
            }
        }
        
        if let Ok(sets) = parser.parse_netflow_packet(&packet_2) {
            for set in sets {
                let s = set.to_json();
                assert!(s.contains("\"BGP IPv4 Next Hop\": \"0.0.0.0\""));
                assert!(s.contains("\"Forwarding Status\": \"66\""));
                assert!(s.contains("\"IPv4 Next Hop\": \"0.0.0.0\""));
                assert!(s.contains("\"L4 Src port\": \"49152\""));
                assert!(s.contains("\"IPv6 Options header\": \"0\""));
                assert!(s.contains("\"Protocol\": \"17\""));
                assert!(s.contains("\"IPv6 Src Addr\": \"2a0b:ae00:0121:0000:0000:0000:0000:0004\""));
                assert!(s.contains("\"InPackets\": \"1\""));
                assert!(s.contains("\"BGP IPv6 Next Hop\": \"2a0b:ae00:0121:0000:0000:0000:0000:0005\""));
                assert!(s.contains("\"InBytes\": \"72\""));
                assert!(s.contains("\"First switched\": \"1668894188\""));
                assert!(s.contains("\"Src AS\": \"207044\""));
                assert!(s.contains("\"Multicast replication factor\": \"0\""));
                assert!(s.contains("\"L4 Dst port\": \"3784\""));
                assert!(s.contains("\"IPv6 Dst Mask\": \"127\""));
                assert!(s.contains("\"Input SNMP\": \"0\""));
                assert!(s.contains("\"ICMP type\": \"0\""));
                assert!(s.contains("\"Last Switched\": \"1668894188\""));
                assert!(s.contains("\"TCP Flags\": \"0\""));
                assert!(s.contains("\"IPv6 Flow Label\": \"0\""));
                assert!(s.contains("\"IPv6 Src Mask\": \"128\""));
                assert!(s.contains("\"Src Tos\": \"192\""));
                assert!(s.contains("\"IP Proto version\": \"6\""));
                assert!(s.contains("\"IPv6 Dst Addr\": \"2a0b:ae00:0121:0000:0000:0000:0000:0005\""));
                assert!(s.contains("\"Direction\": \"1\""));
                assert!(s.contains("\"IPv6 Next Hop\": \"0000:0000:0000:0000:0000:0000:0000:0000\""));
                assert!(s.contains("\"Output SNMP\": \"276\""));
                assert!(s.contains("\"Dst AS\": \"207044\""));
            }
        }
    }
}
